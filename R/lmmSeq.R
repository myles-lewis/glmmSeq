setClassUnion("character_or_list", c("character", "list"))
setClassUnion("df_or_matrix", c("data.frame", "matrix"))

#' An S4 class to define the lmmSeq output
#'
#' @slot info List including matched call, offset, designMatrix
#' @slot formula The model formula
#' @slot stats Statistics from fitted models
#' @slot predict Predicted values
#' @slot reducedFormula The reduced formula with removed random effects
#' @slot maindata The input expression data with variables in rows
#' @slot metadata The input metadata
#' @slot modelData Model data for predictions
#' @slot optInfo Information on whether the model was singular or converged
#' @slot errors Any errors
#' @slot vars List of variables stored from the original call

setClass("lmmSeq", slots = list(
  info = "list",
  formula = "formula",
  stats = "list",
  predict = "df_or_matrix",
  reducedFormula = "formula",
  maindata = "df_or_matrix",
  metadata = "df_or_matrix",
  modelData = "df_or_matrix",
  optInfo = "matrix",
  errors = "character_or_list",
  vars = "list"
))


#' Linear mixed models for data matrix
#'
#' Fits many linear mixed effects models for analysis of gaussian data with
#' random effects, with parallelisation and optimisation for speed. It is
#' suitable for longitudinal analysis of high dimensional data. Wald type 2
#' Chi-squared test is used to calculate p-values.
#'
#' @param modelFormula the model formula. This must be of the form `"~ ..."`
#'   where the structure is assumed to be `"gene ~ ..."`. The formula must
#'   include a random effects term. See formula structure for random effects in
#'   \code{\link[lme4:lmer]{lme4::lmer()}}
#' @param maindata data matrix with genes in rows and samples in columns
#' @param metadata a dataframe of sample information with variables in columns
#'   and samples in rows
#' @param id Optional. Used to specify the column in metadata which contains the
#'   sample IDs to be used in repeated samples for random effects. If not
#'   specified, the function defaults to using the variable after the "|" in the
#'   random effects term in the formula.
#' @param offset Vector containing model offsets (default = NULL). If provided
#'   the `lmer()` offset is set to `offset`. See
#'   \code{\link[lme4:lmer]{lme4::lmer()}}
#' @param reducedFormula Optional design formula without random effects. If not
#'   given, it is automatically generated by removing the random effects from
#'   the main formula. Used to calculate confidence intervals for final fitted
#'   models on each gene for plotting purposes.
#' @param modelData Optional dataframe. Default is generated by call to
#'   `expand.grid` using levels of variables in the formula. Used to calculate
#'   model predictions for plotting.
#' @param designMatrix Optional custom design matrix generated by call to
#'   `model.matrix` using `modelData` and `reducedFormula`. Used to calculate
#'   model predictions for plotting.
#' @param control the `lmer` optimizer control (default = `lmerControl()`). See
#'   \code{\link[lme4:lmerControl]{lme4::lmerControl()}}.
#' @param cores number of cores to use for parallelisation. Default = 1. 
#' @param removeSingles whether to remove individuals with no repeated measures
#'   (default = FALSE)
#' @param verbose Logical whether to display messaging (default = TRUE)
#' @param returnList Logical whether to return results as a list or lmmSeq 
#' object (default = FALSE). Helpful for debugging.
#' @param progress Logical whether to display a progress bar
#' @param ... Other parameters passed to \code{\link[lme4:lmer]{lme4::lmer()}}
#' @return Returns an S4 class `lmmSeq` object with results for gene-wise
#'   linear mixed models or a list of results if `returnList` is `TRUE`.
#' @importFrom lme4 subbars findbars lmer fixef lmerControl nobars isSingular
#' @importFrom lmerTest lmer
#' @importFrom parallel mclapply detectCores parLapply makeCluster clusterEvalQ
#'   clusterExport stopCluster
#' @importFrom pbmcapply pbmclapply
#' @importFrom pbapply pblapply
#' @importFrom methods slot new
#' @importFrom stats AIC complete.cases logLik reshape terms vcov pchisq
#'   update.formula model.matrix predict setNames
#' @export
#' @examples
#' data(PEAC_minimal_load)
#' logtpm <- log2(tpm +1)
#' lmmtest <- lmmSeq(~ Timepoint * EULAR_6m + (1 | PATID),
#'                      maindata = logtpm["MS4A1", ],
#'                      metadata = metadata,
#'                      verbose = FALSE)
#' names(attributes(lmmtest))


lmmSeq <- function(modelFormula,
                   maindata,
                   metadata,
                   id = NULL,
                   offset = NULL,
                   test.stat = c("Wald", "F"),
                   reducedFormula = "",
                   modelData = NULL,
                   designMatrix = NULL,
                   control = lmerControl(),
                   cores = 1,
                   removeSingles = FALSE,
                   verbose = TRUE,
                   returnList = FALSE, 
                   progress = FALSE,
                   ...) {
  lmmcall <- match.call(expand.dots = TRUE)
  test.stat <- match.arg(test.stat)
  # Catch errors
  if (length(findbars(modelFormula)) == 0) {
    stop("No random effects terms specified in formula")
  }
  if (ncol(maindata) != nrow(metadata)) {
    stop("maindata columns different size to metadata rows")
  }
  if (!is.null(offset) & ncol(maindata) != length(offset)) {
    stop("Different offset length")
  }
  
  # Manipulate formulae
  fullFormula <- update.formula(modelFormula, gene ~ ., simplify = FALSE)
  nonRandomFormula <- subbars(modelFormula)
  variables <- rownames(attr(terms(nonRandomFormula), "factors"))
  subsetMetadata <- metadata[, variables]
  if (is.null(id)) {
    fb <- findbars(modelFormula)
    id <- sub(".*[|]", "", fb)
    id <- gsub(" ", "", id)
  }
  ids <- as.character(metadata[, id])
  
  # Option to subset to remove unpaired samples
  if (removeSingles) {
    nonSingle <- names(table(ids))[table(ids) > 1]
    pairedIndex <- ids %in% nonSingle
    maindata <- maindata[, pairedIndex]
    subsetMetadata <- subsetMetadata[pairedIndex, ]
    ids <- ids[pairedIndex]
    offset <- offset[pairedIndex]
  }
  
  if (verbose) cat(paste0("\nn = ", length(ids), " samples, ",
                          length(unique(ids)), " individuals\n"))
  
  # setup model prediction
  if (reducedFormula == "") reducedFormula <- nobars(modelFormula)
  if (is.null(modelData)) {
    reducedVars <- rownames(attr(terms(reducedFormula), "factors"))
    varLevels <- lapply(reducedVars, function(x) {
      if (is.factor(metadata[, x])) {
        return(levels(subsetMetadata[, x]))
      } else {sort(unique(subsetMetadata[, x]))}
    })
    modelData <- expand.grid(varLevels)
    colnames(modelData) <- reducedVars
  } 
  
  if (is.null(designMatrix)){
    designMatrix <- model.matrix(reducedFormula, modelData)
  } 
  
  # Adapted from car:::Anova.II.mer
  reduced2 <- nobars(fullFormula)
  fac <- attr(terms(reduced2), "factors")
  data2 <- metadata
  data2[,'gene'] <- rep(0, nrow(data2)) 
  dm2 <- model.matrix(reduced2, data2)
  assign <- attr(dm2, "assign")
  term.labels <- attr(terms(reduced2), "term.labels")
  p <- length(assign)
  I.p <- diag(p)
  n.terms <- length(term.labels)
  hyp.matrix.1 <- hyp.matrix.2 <- list()
  for (i in seq_len(n.terms)) {
    which.term <- i
    subs.term <- which(assign == which.term)
    relatives <- car_relatives(term.labels[i], term.labels, fac)
    subs.relatives <- NULL
    for (relative in relatives) subs.relatives <- c(subs.relatives, 
                                                    which(assign == relative))
    hyp.matrix.1[[i]] <- I.p[subs.relatives, , drop = FALSE]
    hyp.matrix.2[[i]] <- I.p[c(subs.relatives, subs.term), , drop = FALSE]
  }
  names(hyp.matrix.1) <- term.labels
  
  start <- Sys.time()
  fullList <- lapply(rownames(maindata), function(i) as.numeric(maindata[i, ]))
  
  # For each gene perform a fit
  if (Sys.info()["sysname"] == "Windows" & cores > 1) {
    cl <- makeCluster(cores)
    clusterExport(cl, varlist = c("lmerCore", "fullList", "fullFormula",
                                  "subsetMetadata", "control", "modelData",
                                  "offset", "designMatrix",
                                  "hyp.matrix.1", "hyp.matrix.2", ...),
                  envir = environment())
    if (progress) {
      resultList <- pblapply(fullList, function(geneList) {
        lmerCore(geneList, fullFormula = fullFormula, data = subsetMetadata,
                 control = control, modelData = modelData, offset = offset,
                 designMatrix = designMatrix,
                 hyp.matrix.1 = hyp.matrix.1,
                 hyp.matrix.2 = hyp.matrix.2,
                 test.stat = test.stat, ...)
      }, cl = cl)
    } else {
      resultList <- parLapply(cl = cl, fullList, function(geneList) {
        lmerCore(geneList, fullFormula = fullFormula, data = subsetMetadata,
                 control = control, modelData = modelData, offset = offset,
                 designMatrix = designMatrix,
                 hyp.matrix.1 = hyp.matrix.1,
                 hyp.matrix.2 = hyp.matrix.2,
                 test.stat = test.stat, ...)
      })
    }
    stopCluster(cl)
  } else{
    if (progress) {
      resultList <- pbmclapply(fullList, function(geneList) {
        lmerCore(geneList, fullFormula = fullFormula, data = subsetMetadata,
                 control = control, modelData = modelData, offset = offset,
                 designMatrix = designMatrix,
                 hyp.matrix.1 = hyp.matrix.1,
                 hyp.matrix.2 = hyp.matrix.2,
                 test.stat = test.stat, ...)
      }, mc.cores = cores)
      if ("value" %in% names(resultList)) resultList <- resultList$value
    } else {
      resultList <- mclapply(fullList, function(geneList) {
        lmerCore(geneList, fullFormula = fullFormula, data = subsetMetadata,
                 control = control, modelData = modelData, offset = offset,
                 designMatrix = designMatrix,
                 hyp.matrix.1 = hyp.matrix.1,
                 hyp.matrix.2 = hyp.matrix.2,
                 test.stat = test.stat, ...)
      }, mc.cores = cores)
    }
  }
  if(returnList) return(resultList)
  
  # Print timing if verbose
  end <- Sys.time()
  if (verbose) print(end - start)
  
  # Output
  names(resultList) <- rownames(maindata)
  noErr <- vapply(resultList, function(x) x$tryErrors == "", FUN.VALUE = TRUE)
  if (length(which(noErr)) == 0) { 
    stop("All genes returned an error. Check sufficient data in each group")
  }
  
  predList <- lapply(resultList[noErr], "[[", "predict")
  outputPredict <- do.call(rbind, predList)
  
  outLabels <- apply(modelData, 1, function(x) paste(x, collapse = "_"))
  colnames(outputPredict) <- c(paste0("y_", outLabels),
                               paste0("LCI_", outLabels),
                               paste0("UCI_", outLabels))
  
  if (sum(!noErr) != 0) {
    if (verbose) cat(paste0("Errors in ", sum(!noErr), " gene(s):",
                            paste0(names(noErr)[! noErr], collapse = ", ")))
    outputErrors <- vapply(resultList[!noErr], function(x) {x$tryErrors},
                           FUN.VALUE = character(1))
  } else {outputErrors <- c("No errors")}
  
  optInfo <- t(vapply(resultList[noErr], function(x) {
    setNames(x$optinfo, c("Singular", "Conv"))
  }, FUN.VALUE = c(1, 1)))
  
  statsList <- lapply(resultList[noErr], "[[", "stats")
  s <- do.call(rbind, statsList)
  coefList <- lapply(resultList[noErr], "[[", "coef")
  cf <- do.call(rbind, coefList)
  SEList <- lapply(resultList[noErr], "[[", "stdErr")
  stdErr <- do.call(rbind, SEList)
  if (test.stat == "Wald") {
    chisqList <- lapply(resultList[noErr], "[[", "chisq")
    chisq <- do.call(rbind, chisqList)
    dfList <- lapply(resultList[noErr], "[[", "df")
    df <- do.call(rbind, dfList)
    pvals <- pchisq(chisq, df=df, lower.tail = FALSE)
    colnames(df) <- colnames(chisq)
    colnames(pvals) <- colnames(chisq)
    s <- list(res = s, coef = cf, stdErr = stdErr, Chisq = chisq, Df = df,
              pvals = pvals)
  } else {
    NumDF <- lapply(resultList[noErr], function(x) x$Ftest[,1])
    NumDF <- do.call(rbind, NumDF)
    DenDF <- lapply(resultList[noErr], function(x) x$Ftest[,2])
    DenDF <- do.call(rbind, DenDF)
    Fval <- lapply(resultList[noErr], function(x) x$Ftest[,3])
    Fval <- do.call(rbind, Fval)
    pvals <- lapply(resultList[noErr], function(x) x$Ftest[,4])
    pvals <- do.call(rbind, pvals)
    s <- list(res = s, coef = cf, stdErr = stdErr, NumDF = NumDF, DenDF = DenDF, 
              Fval = Fval, pvals = pvals)
  }
  
  # Create lmmSeq object with results
  new("lmmSeq",
      info = list(call = lmmcall,
                  offset = offset,
                  designMatrix = designMatrix,
                  control = substitute(control),
                  test.stat = test.stat),
      formula = fullFormula,
      stats = s,
      predict = outputPredict,
      reducedFormula = reducedFormula,
      maindata = maindata,
      metadata = subsetMetadata,
      modelData = modelData,
      optInfo = optInfo,
      errors = outputErrors,
      vars = list(id = id,
                  removeSingles = removeSingles)
  )
}


lmerCore <- function(geneList,
                     fullFormula,
                     data,
                     control,
                     modelData,
                     designMatrix,
                     offset,
                     hyp.matrix.1,
                     hyp.matrix.2,
                     test.stat,
                     ...) {
  data[, "gene"] <- geneList
  if (test.stat == "Wald") {
  fit <- try(suppressMessages(suppressWarnings(
    lme4::lmer(fullFormula, data = data, control = control, offset = offset,
               ...))),
    silent = TRUE)
  } else {
    fit <- try(suppressMessages(suppressWarnings(
      lmerTest::lmer(fullFormula, data = data, control = control, offset = offset,
                     ...))),
      silent = TRUE)
  }
  if (!inherits(fit, "try-error")) {
    # intercept dropped genes
    if (length(attr(fit@pp$X, "msgRankdrop")) > 0)  {
      return( list(stats = NA, predict = NA, optinfo = NA,
                   tryErrors = attr(fit@pp$X, "msgRankdrop")) )
    }
    stats <- setNames(c(AIC(fit), as.numeric(logLik(fit))),
                      c("AIC", "logLik"))
    fixedEffects <- lme4::fixef(fit)
    stdErr <- coef(summary(fit))[, 2]
    vcov. <- suppressWarnings(vcov(fit, complete = FALSE))
    vcov. <- as.matrix(vcov.)
    if (test.stat == "Wald") {
      waldtest <- lmer_wald(fixedEffects, hyp.matrix.1, hyp.matrix.2, vcov.)
    } else {
      Ftest <- as.matrix(anova(fit)[, -c(1,2)])
    }
      
    newY <- predict(fit, newdata = modelData, re.form = NA)
    a <- designMatrix %*% vcov.
    b <- as.matrix(a %*% t(designMatrix))
    predVar <- diag(b)
    newSE <- sqrt(predVar)
    newLCI <- newY - newSE * 1.96
    newUCI <- newY + newSE * 1.96
    predictdf <- c(newY, newLCI, newUCI)
    singular <- as.numeric(lme4::isSingular(fit))
    conv <- length(slot(fit, "optinfo")$conv$lme4$messages)
    rm(fit, data)
    ret <- if (test.stat == "Wald") {
      list(stats = stats,
           coef = fixedEffects,
           stdErr = stdErr,
           chisq = waldtest$chisq,
           df = waldtest$df,
           predict = predictdf,
           optinfo = c(singular, conv),
           tryErrors = "")
    } else {
      list(stats = stats,
           coef = fixedEffects,
           stdErr = stdErr,
           Ftest = Ftest,
           predict = predictdf,
           optinfo = c(singular, conv),
           tryErrors = "")
    }
    return(ret)
  } else {
    return(list(stats = NA, coef = NA, stdErr = NA, chisq = NA, df = NA, 
                predict = NA, optinfo = NA, tryErrors = fit[1]))
  }
}


lmer_wald <- function(fixef, hyp.matrix.1, hyp.matrix.2, vcov.) {
  
  hyp.list <- lapply(seq_along(hyp.matrix.1), function(i) {
  # source car:::Anova.II.mer
    hyp.matrix.term <- if (nrow(hyp.matrix.1[[i]]) == 0) 
    {hyp.matrix.2[[i]]
    } else t(car_ConjComp(t(hyp.matrix.1[[i]]), t(hyp.matrix.2[[i]]), vcov.))
    hyp.matrix.term <- hyp.matrix.term[!apply(hyp.matrix.term, 
                                              1, function(x) all(x == 0)), , drop = FALSE]
    hyp.matrix.term
  })
  # source car:::linearHypothesis.mer()
  b <- fixef
  V <- vcov.
  # rhs = 0
  chi_val <- lapply(hyp.list, function(L) {
    as.vector(t(L %*% b) %*% solve(L %*% V %*% 
                                           t(L)) %*% (L %*% b))
  })
  df <- unlist(lapply(hyp.list, NROW))
  list(chisq = setNames(unlist(chi_val), names(hyp.matrix.1)),
       df = df)
}



## Source car:::ConjComp
car_ConjComp <- function (X, Z = diag(nrow(X)), ip = diag(nrow(X))) 
  {
    xq <- qr(t(Z) %*% ip %*% X)
    if (xq$rank == 0) 
      return(Z)
    Z %*% qr.Q(xq, complete = TRUE)[, -(1:xq$rank)]
  }


## Source car:::relatives
car_relatives <- function (term, names, factors) 
  {
    is.relative <- function(term1, term2) {
      all(!(factors[, term1] & (!factors[, term2])))
    }
    if (length(names) == 1) 
      return(NULL)
    which.term <- which(term == names)
    (1:length(names))[-which.term][sapply(names[-which.term], 
                                          function(term2) is.relative(term, term2))]
  }


#' @export

summary.lmmSeq <- function(x, rows = NULL,
                           digits = max(3L, getOption("digits") - 3L)) {
  if (is.null(rows)) {
    statSet <- names(x@stats)
    gp <- lapply(statSet, function(i) {
      out <- x@stats[[i]]
      if (i %in% c("Chisq", "Fval", "Df", "NumDF", "DenDF")) colnames(out) <- paste(i, colnames(out), sep = "_")
      if (i == "pvals") colnames(out) <- paste0("P_", colnames(out))
      if (i == "stdErr") colnames(out) <- paste0("se_", colnames(out))
      out
    })
    do.call(cbind, gp)
  } else {
    out <- lapply(x@stats, function(i) i[rows,])
    cat("Linear mixed model\n")
    print(out$res)
    cat("\nFixed effects:\n")
    cfdf <- data.frame(Estimate = out$coef,
                       `Std. Error` = out$stdErr, check.names = FALSE)
    print(cfdf, digits = digits)
    if (x@info$test.stat == "Wald") {
      cat("\nAnalysis of Deviance Table (Type II Wald chisquare tests)\n")
      testdf <- data.frame(Chisq = out$Chisq,
                           Df = out$Df,
                           `Pr(>Chisq)` = out$pvals, check.names = FALSE)
    } else {
      cat("\nType III Analysis of Variance Table with Satterthwaite's method\n")
      testdf <- data.frame(NumDF = out$NumDF,
                           DenDF = out$DenDF,
                           `F value` = out$Fval,
                           `Pr(>F)` = out$pvals, check.names = FALSE)
    }
    print(testdf, digits = digits)
    invisible(out)
  }
}
